= Overview

== Requirements

The default serialised data representations for openEHR content are canonical XML, based on the {openehr_its_xml_releases}[openEHR RM XSDs^], canonical JSON, described by the {openehr_its_json_releases}[openEHR JSON schemas^], and potentially any other canonical serial format based on the underlying Reference Model (e.g. YAML etc). Here, 'canonical' means any fully-expressed instance data in which all RM mandatory fields are present, all attributes are named as per the RM, and all cardinalities respect the RM.

The canonical formats are routinely used by all openEHR implementations implementing the {openehr_ehr_rest_api}[openEHR REST API specification^], and in many other ways, e.g. for DB dump/load implementation, ETL and so on. However, creating data instances according to these formats is not always straightforward, particularly for developers with minimal exposure to openEHR, and various alternatives have been used in the past to simplify the job of content creation and committal for application developers.

This specification responds to the requirement for a minimal but formally complete serial form of content creation for openEHR applications.

== Conceptual Approach

The information models of openEHR are structured in multiple layers, with the primary distinction being between an information model layer (the 'Reference Model' or RM), and domain-level models expressed in archetypes and templates, that latter of which express particular data sets. Each such data set is defined in terms of an {openehr_am_opt2}[openEHR Operational Template (OPT)^], derived from a source template, and ultimately particular archetypes, which are themselves constraint models based on the RM, i.e. the 'canonical model.

The openEHR reference model (RM) and supporting models (BASE component) are designed with two computational goals in mind:

* data instances (healthcare data) are fully defined and self-standing, for example if shared with a data partner that does not use openEHR;
* software that implements the model works in regular, expected ways; for example, the structure of the openEHR `OBSERVATION`, `HISTORY` and `EVENT` classes will generically represent any observation, from a single weight measurement to 100,000 samples of complex vital signs data.

The model is accordingly rigorous. However, for some developers who only need to instantiate, commit and/or read relatively limited data-sets, the canonical format can be demanding. This is particularly so for situations in which only a few kinds of data are implicated, i.e. a relatively small number of templates, e.g. vitals signs data, lab results etc.

The starting point for defining a developer-friendly commit format is therefore to assume that the great majority of applications are typically targetted to one or a few specific data sets, e.g. vital signs, diabetic monitoring, pregnancy plan etc. 

Template-specificity provides a route for defining and generating a serial format such that _each openEHR template_ can be used to define one or more reasonably simple commit formats. Two such formats are discussed here:

* _near-canonical RM JSON data template (ncJDT)_, originally devised for the EtherCIS project;
* _simplified IM JSON data template (sJDT)_, based on the 'web template' format originally created by Marand for the Better platform.

The first of these is an extract from an Operational Template (OPT) that uses AQL-style paths, and apart from simplification of the `DV_XXX` and `PARTY_PROXY` types, retains the openEHR RM structure. The latter is based on a more radical simplification of the openEHR RM and BASE models, as well as a more programmer-friendly rendering of paths. Under the latter approach, a lab result data structure could be represented using non-canonical attribute or tag names such as 'serum_sodium', 'serum_potassium', etc (or in any other natural language, including script-based languages), instead of each node appearing under the canonical `CLUSTER._items_` attribute.

To make any form of 'simplified format' work, the following requirements must be met:

* the format makes it possible to _abstract away rigorous structural complexity_ of the canonical model where possible, mainly by making the data less self-standing, and relying more on a schema;
* the format definition for any given commit data can be completely and routinely _machine generated_ from its canonical definition, i.e. from an openEHR OPT, or other upstream canonical definition;
* data instances of the simplified format definition can be _routinely converted to canonical format_ at execution time.

A generic high-level algorithm for creating both kinds of data template definition from an Operational Template (OPT) is illustrated below.

[.text-center]
.Scheme for generation of JSON Template definitions
image::{diagrams_uri}/simplified_template_definition.svg[id=simplified_template_definition, align="center"]

In the above, both the near-canonical data and simplified data template definitions are created via a series of transformations starting with an OPT, followed by RM flattening, and then two stages of JSON format generation. The more heavily simplified form is created via an extra step, in which an original OPT is converted by the `sOPT transformer` to a _simplified OPT (sOPT)_, which is a regular-structured OPT, but whose underlying reference model is a Simplified Information Model (SIM), based on the canonical Reference Model (RM) and related openEHR Information Models (Base, etc).

TODO: this is not 100% true; in fact, even the near-canonical data template has to be generated via an sOPT step.

The SIM is approximately a _logical sub-set_ of classes relevant to the definition of EHR commitable content, with each class being a potentially simplified form of one or more classes in the RM. The simplifications may consist of:

* merging of Composition relationships (de-normalisation), which has the effect of reducing data path depth; i.e. in some cases, 2 RM classes are replaced by a single SIM class, which is relatively easy in the case of `0..1` and `1..1` relationships;
* stringification of specific attributes, i.e. replacement of (usually low-level) types with `String`, so that the attribute may contain a string form of a complex object.

These rules are formalised in the model-to-model Transformation rules shown above. Using the SIM and the rules, a Simplified OPT (sOPT) can be generated from any Operational Template (OPT), and from there, various concrete form Simplified Templates (STs) may be generated, including JSON 'flat' and 'sparse' forms. The sOPT is a regular OPT in the formal sense, and can be processed by any tool that accepts an OPT as an input.

Instances of both JSON flat and sparse simplified template formats can be created by developers to represent openEHR data to be committed to a system. These will be converted to canonical RM format (also obeying their original OPTs) by a Simplified Template -> RM converter on the serve side at data commit time, as shown in the following diagram.

[.text-center]
.Scheme for conversion of Simplified Template instance to canonical form
image::{diagrams_uri}/simplified_template_data_conversion.svg[id=simplified_template_conversion, align="center"]

Following this scheme, this specification describes the Simplified Reference Model (SIM), Simplified OPT Transformer (sOPT Transformer), and the downstream JSON concrete formats and the ST -> canonical instance converter.